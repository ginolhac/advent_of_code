---
title: "03"
format: html
---

```{r}
#| label: setup
#| include: false
library(tidyverse)
library(bit64) # because R limitation .Machine$integer.max -> 2147483647
library(RcppAlgos)
library(tictoc)

options(scipen = 999)
```


## Part 1


```{r}
input <- "987654321111111
811111111111119
234234234234278
818181911112111"

banks <- read_lines(input)
banks <- read_lines("input/03")
head(banks)
```


```{r}
combi_max_banks <- function(b) {
  str_split_1(b, pattern = "") |> 
  combn(2, simplify = FALSE) |> 
  map_int(\(x) paste(x, collapse = "") |> as.integer()) |> 
  max()
}

tic()
map_int(banks, combi_max_banks) |> 
  sum()
toc()
```


1.88 sec 17405


## Part 2

```{r}
combi_max_banks2 <- function(b) {
  str_split_1(b, pattern = "") |> 
  as.double() |> 
  comboGeneral(12, Parallel = FALSE, FUN = \(x) paste(x, collapse = '') |> as.double(), FUN.VALUE = as.double(1)) |> 
  max()
}

tic()
map_dbl(banks, combi_max_banks2) |> 
  sum()
toc()

```

Works on example, then too big for combination

Using recursion following [**serialc**](https://github.com/serialc/AdventOfCode/blob/main/2025/day03/day03.py) idea


```{r}
largest_number <- function(nums, n_digits) {
  if (n_digits < 1) return(0)
  
  
  digit <- max(nums[1:(length(nums) - n_digits + 1)])
  i <- which.max(nums[1:(length(nums) - n_digits + 1)])
  
  n_digits <- n_digits - 1
  
  # end recursion, format and coerce
  if (n_digits == 1) {
    return(paste(digit,  max(nums[(i + 1):length(nums)])))
  }
  
  paste(digit, largest_number(nums[(i + 1):length(nums)], n_digits), collapse = '')
}

tic()
banks |> 
  map(\(b) str_split_1(b, '') |> 
        as.integer() |> 
        largest_number(12) ) |> 
  str_replace_all(' ', '') |> 
  as.double() |> 
  sum()
toc()

```


[1] 171990312704598
0.06 sec elapsed

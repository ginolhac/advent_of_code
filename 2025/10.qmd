---
title: "10"
format: html
---

```{r}
#| label: setup
#| include: false
library(tidyverse)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk) # yay glpk first
library(tictoc)
options(scipen = 999)
```

## Part 1

**Factory**


- indicator light diagram in [square brackets]
- button wiring schematics in (parentheses)
- joltage requirements in {curly braces}

```{r}
input <- "[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}
[...#.] (0,2,3,4) (2,3) (0,4) (0,1,2) (1,2,3,4) {7,5,12,7,2}
[.###.#] (0,1,2,3,4) (0,3,4) (0,1,2,4,5) (1,2) {10,11,11,5,10,5}"

instructions <- read_lines(input)
#input <- "input/10"

parse_factory <- function(line) {
  lights <- str_extract(line, "\\[(.+)\\]", group = 1) |> 
    str_replace_all(c("\\." = "0", "#" = "1")) |> 
    str_split_1('') |> as.integer()
  buttons <- str_extract(line, "(\\(.+\\))", group = 1) |> 
    str_split_1(' ') |> map(\(i) {
      str_remove_all(i, "[\\(\\)]") |> 
        str_split_1(',') |> 
        as.numeric()
    })
  # since 0-based offset
  buttons <- map(buttons, \(i) {
    one_based <- i + 1
  # convert indices to values of 1 and rest zero
    res <- vector(mode = "integer", length = length(lights))
    res[one_based] <- 1
    res
    })
  joltages <- str_extract(line, "\\{(.+)\\}", group = 1) |> 
    str_split_1(',') |> as.integer()
  list(lights = lights,
       buttons = buttons,
       joltages = joltages)
}
ll <- parse_factory(instructions[1])
ll
```


## Testing Mixed Integer Linear Programming

- `solve()` is not fine since we have more variables than equations.
- `qr.solve()` is returning float
- `lpSolve` doc is not clear enough

Trying than [`{ompr}`](https://dirkschumacher.github.io/ompr/) by **Dirk Schumacher**

```{r}


A <- matrix(c(c(1, 0, 0, 1),
              c(0, 1, 0, 1),
              c(0, 0, 1, 0),
              c(0, 0, 1, 1),
              c(1, 0, 1, 0),
              c(1, 1, 0, 0)), nrow = 4)
A

goal <- c(0, 1, 1, 0)

A

model <- MIPModel() |> 
  # buttons
  add_variable(x[i], i = 1:6, type = "binary") |> 
  # expected results
  add_variable(k[i], i = 1:4, type = "integer") |> 
  # button (5, 6) for a even result (0)
  add_constraint(sum_over(x[i], i = c(5, 6)) == 2 * k[1]) |> 
  # odd result (1)
  add_constraint(sum_over(x[i], i = c(2, 6)) == 2 * k[2] + 1) |> 
  add_constraint(sum_over(x[i], i = c(3, 4, 5)) == 2 * k[3] + 1) |> 
  add_constraint(sum_over(x[i], i = c(1, 2, 4)) == 2 * k[4]) |> 
  set_objective( sum_over(x[i], i = 1:6), sense = "min") |> 
  solve_model(with_ROI(solver = "glpk", verbose = TRUE))
get_solution(model, k[i])

```




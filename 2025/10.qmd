---
title: "10"
format: html
---

```{r}
#| label: setup
#| include: false
library(tidyverse)
library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk) # yay glpk first
library(tictoc)
options(scipen = 999)
```

## Part 1

**Factory**


- indicator light diagram in [square brackets]
- button wiring schematics in (parentheses)
- joltage requirements in {curly braces}

```{r}
input <- "[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}
[...#.] (0,2,3,4) (2,3) (0,4) (0,1,2) (1,2,3,4) {7,5,12,7,2}
[.###.#] (0,1,2,3,4) (0,3,4) (0,1,2,4,5) (1,2) {10,11,11,5,10,5}"

input <- "input/10"
instructions <- read_lines(input)

parse_factory <- function(line) {
  lights <- str_extract(line, "\\[(.+)\\]", group = 1) |> 
    str_replace_all(c("\\." = "0", "#" = "1")) |> 
    str_split_1('') |> as.integer()
  buttons <- str_extract(line, "(\\(.+\\))", group = 1) |> 
    str_split_1(' ') |> map(\(i) {
      str_remove_all(i, "[\\(\\)]") |> 
        str_split_1(',') |> 
        as.numeric()
    })
  # since 0-based offset
  buttons <- map(buttons, \(i) {
    one_based <- i + 1
  # convert indices to values of 1 and rest zero
    res <- vector(mode = "integer", length = length(lights))
    res[one_based] <- 1
    res
    })
  joltages <- str_extract(line, "\\{(.+)\\}", group = 1) |> 
    str_split_1(',') |> as.integer()
  list(lights = lights,
       buttons = buttons,
       joltages = joltages)
}
switches <- map(instructions, parse_factory)
length(switches)
```


## Testing Mixed Integer Linear Programming

- `solve()` is not fine since we have more variables than equations.
- `qr.solve()` is returning float
- `lpSolve` doc is not clear enough

Trying than [`{ompr}`](https://dirkschumacher.github.io/ompr/) by **Dirk Schumacher**

Thanks **Hugues esc_** for the help the binary answers for the lights!

```{r}


build_model_part1 <- function(switches) {
  
  mat <- switches$buttons |> 
    flatten_int() |> 
    matrix(nrow = length(switches$lights), byrow = FALSE)
  
  
  model <- MIPModel() |> 
    # buttons
    add_variable(x[i], i = seq_along(switches$buttons), type = "binary") |> 
    # expected results
    add_variable(k[i], i = seq_along(switches$lights), type = "integer", lb = 0)
  
  for (button in seq_along(switches$lights)) {
    if (switches$lights[button] == 0) {
      model <- add_constraint(model, sum_over(x[i], i = which(mat[button, ] == 1)) == 2 * k[button])
    } else {
      model <- add_constraint(model, sum_over(x[i], i = which(mat[button, ] == 1)) == 2 * k[button] + 1)
    }
  }
  
  model <- set_objective(model, sum_over(x[i], i = seq_along(switches$buttons)), sense = "min") |> 
    solve_model(with_ROI(solver = "glpk", verbose = FALSE))
  #get_solution(model, x[i])
  objective_value(model)
}
tic()
map_int(switches, build_model_part1) |> sum()
toc()
```

547 10.674 secs


example of output of `extract_constraints(model)` for first example
```
$matrix
4 x 10 sparse Matrix of class "dgCMatrix"
                            
[1,] . . . . 1 1 -2  .  .  .
[2,] . 1 . . . 1  . -2  .  .
[3,] . . 1 1 1 .  .  . -2  .
[4,] 1 1 . 1 . .  .  .  . -2

$sense
[1] "==" "==" "==" "=="

$rhs
[1] 0 1 1 0
```

## Part 2

```{r}
build_model_part2 <- function(switches) {
  
  mat <- switches$buttons |> 
    flatten_int() |> 
    matrix(nrow = length(switches$lights), byrow = FALSE)
  
  
  model <- MIPModel() |> 
    # buttons
    add_variable(x[i], i = seq_along(switches$buttons), type = "integer", lb = 0)
  
  for (button in seq_along(switches$lights)) {
      model <- add_constraint(model, sum_over(x[i], i = which(mat[button, ] == 1)) == switches$joltages[button])
  }
  
  model <- set_objective(model, sum_over(x[i], i = seq_along(switches$buttons)), sense = "min") |> 
    solve_model(with_ROI(solver = "glpk", verbose = FALSE))
  #get_solution(model, x[i])
  objective_value(model)
}
tic()
map_int(switches, build_model_part2) |> sum()
toc()
```

21111 9.666 sec elapsed
